%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%       PART I
%
%       BTRON/386
%       
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{BTRON/386}

\chapter{構成要素の概要}

\begin{quote}
BTRON/386 は、いくつかの構成要素に分かれたモジュール構造をしている。
構成要素とは、「カーネル(ITRON)」「BTRON サーバ」「マネージャ」「アプ
リケーションである。

この章では、各構成要素についてその役割を説明する。
\end{quote}

\newpage
%
%
%
\section{カーネル}
\subsection{定義}

BTRON/386 では、カーネルを次のような意味で使っている。

\begin{description}
\item[カーネル]
        ユーザプログラムおよびマネージャとハードウェアの間にあり、
        ハードウェアの資源を効率よく管理するプログラム。
\end{description}

\subsection{タスク管理}

\subsubsection{ITRON のタスク管理の設計目標}

\begin{enumerate}
   \item できる限りコンテクストスイッチを速くする。
   \item タスク管理ブロック (TCB) の大きさを小さくする。
\end{enumerate}

  ITRON のタスク管理では、コンテキストを構造体の形では、管理しない。そ
の代りにタスク切り替え時にスタック上にコンテキストを収めるようにする。
  つまり、次に切り換えられるタスクのスタックの一番上にそのタスクのコン
テキストがのっかっていなければならない。


\subsubsection{タスク管理情報}


  タスクを管理する情報としては次のものがある。

\begin{enumerate}
  \item{タスク ID}
  \item{タスク属性}
  \item{タスク状態}
  \item{タスク待ち要因}
  \item{タスク優先度}
  \item{仮想メモリ管理テーブル}
  \item{カーネルスタック}
  \item{IPC (Inter process communication) 用の情報}
  \item{例外処理ハンドラテーブル}
\end{enumerate}

\begin{quote}
  * ITRON レベルでは、ファイルシステムについての情報は意識していない。
    ファイルシステムについての情報については、BTRON レベル(BTRON サー
    バ)で管理する。
\end{quote}

\paragraph{タスク ID}

  タスク ID は、各タスクを識別するための情報である。そのため、タスク 
  ID は、各タスクごとにユニークな番号が割り当てられる。
  本 ITRON では、タスク情報の配列のインデックスが割りあてられる。

\paragraph{タスク属性}

  タスク属性は、タスクを記述する言語が何であるかを示す情報である。
  この情報は ITRON 規約によって決められているものだが、本 ITRON では、
  アセンブラと高級言語で記述されたことの区別はつけないため、常に高級言
  語で記述した場合の値(TA\_HLNG)が入る。

\paragraph{タスク状態}

  現在のタスクの状態を示す。
  タスクの状態は、次に示す値のどれかになっている(マクロ名を示す。括弧
  内は、実際の値)。

  TTS\_NON(0x00000000): 未生成状態。
  TTS\_RUN(0x00000001): 走行状態。この値を示すタスクは、常にシステム内
                        で1つだけである。
  TTS\_RDY(0x00000002): 走行可能状態。
  TTS\_WAI(0x00000004): 待ち状態。自分でイベントを待つことを指定した場
                        合にこの値をもつ。
  TTS\_SUS(0x00000008): 強制待ち状態。他のタスクから強制的に待ち状態に
                        された場合、この値をもつ。
  TTS\_WAS(0x0000000C): タスクが待ち状態に入っている場合に、他のタスク
                        から強制的に待ち状態に、この値をもつ。
  TTS\_DMT(0x00000010): 休止状態。タスクが生成されてはいるがまだ起動さ
                        れていない場合にこの値をもつ。この状態のときに
                        は、タスクは自分の資源をなにも消費していない。

\paragraph{タスク待ち要因}

  TTS\_WAI,TTS\_SUS,TTS\_WASのいずれかの状態のときに、何の要因で待ち状態
  に入っているのかを示す値である。

\paragraph{タスク優先度}

  タスク優先度は、タスクを実行する場合にどのタスクを先に実行するかを示
  す値である。もし、同じ優先度のタスクがあった場合、その優先度のタスク
  リストの先頭にあるタスクが先に実行される。タスクリストについては、タ
  スクの構造を参照のこと。

\paragraph{仮想メモリ管理テーブル}

  タスクごとに必要とする仮想メモリのマッピング情報。
  カーネルモードでは、すべて同じマッピングだが、ユーザモード(アプリケ
ーションプログラム)の領域は、マッピング情報がタスクごとに異なっている。
  仮想メモリ管理テーブルの詳細については、仮想メモリ機能の項目を参照の
  こと。

\paragraph{カーネルスタック}

  タスクごとにもつスタック領域。
  この大きさはタスクの生成時に指定される。本来の ITRON 規約ではバイト
  単位でサイズを指定するが、本 ITRON では、ページサイズに切り上げられ
  る。これは、スタック領域をオーバーフローしたことを関知するために、ス
  タック領域の前後のページを未マップ状態にするためである。スタック領域
  をはずれてアクセスした場合にどのような処理をするかは、例外処理ハンド
  ラとして各タスクごとに指定することができる。

\paragraph{IPC (Inter process communication) 用の情報}

  本 ITRON では、タスク間通信として次の機能をサポートしている。

  1) セマフォ
  2) メッセージ
  3) イベントフラグ

  通信機能に必要な情報は、タスク情報として各タスクに付随している。

\paragraph{例外処理ハンドラテーブル}

  例外が発生した場合に実行されるハンドラへのアドレスを収めるテーブル。
  例外には、次の種類がある。

\begin{enumerate}
  \item{メモリフォールト}
  \item{トラップ (システムコール)}
  \item{浮動小数点例外}
\end{enumerate}

もし、例外発生時にタスク独自の処理をする必要がなければ、システムで決
められた処理を行う。その場合、ハンドラアドレスとしてアドレス 0 (NULL
ポインタ)をセットしておくこと。

例外処理の詳細については、例外処理機能の項目を参照のこと。


\subsubsection{タスク切り替えの方法}

  タスク切り替えは、次のようにして行われる。

\begin{enumerate}
  \item まず前提として、各タスクは独自のスタックをもっている。
        これは、関数呼び出し時などに使われるのはもちろんだが、タスク切り
        替え時には、タスクの情報(コンテキスト)を保存する場所としても使わ
        れる。

  \item タスク切り替えを行う関数
        タスク切り替えは、switch\_task() という関数が行う。
        switch\_task() は、次の呼び出し形式をもつ:

     switch\_task(taskid)
     taskid:    次に切り替えるタスクのID。これは、タスク配列のインデッ
                クスとなっている。

  \item 切り替えるタスクの情報の取得。
        引数に詰まれたタスク ID から、次に実行するタスクのスタックアドレ
        スを取得する。

  \item 現タスクの情報の保存
     swtch\_task()は、最初に現タスク情報をカーネルスタックに保存する。
     保存形式は、以下のとおり。

     Stack Top: [return address] 次にタスクが切り替わったとき
                                 に実行を開始するアドレス。
                [stack pointer]  switch\_task() を呼び出した時点でのス
                                タックのトップアドレス。
                [%ESI]           関数呼び出しによって保存しないレジス
                [%EDI]          タ情報
                [%EBP]
                [%EBX]
     Before stack frame:
                .
                .
                .

  \item コンテキスト情報のロード
     3) で取得したカーネルスタックから、次に切り替えるタスクの情報をロ
     ードする。

  \item 保存していた IP を使ってジャンプ。
     jmp *[return address]
\end{enumerate}


\subsection{同期・通信機構(IPC)}

\subsubsection{RON でサポートしている同期・通信機能}

  本来の ITRON 規約では、セマフォ、イベントフラグ、メイルボックス、メ
ッセージバッファ、ランデブなどが使用できる。しかし、これらの機能をすべ
てをサポートすることは、BTRON/386 を動かすためだけには必要ないと思われ
るので、本 ITRON では、セマフォ、イベントフラグ、メッセージしかサポー
トしていない。
  各 IPC 機能は、次の用途を目的としてサポートした。

\begin{enumerate}
  \item セマフォ
     タスク間の同期をとる。タスク間で共有している情報をアクセスすると
     きなどに使用する。

  \item イベントフラグ
     タスク間で待ち状態を指定するときなどに使用する。
     ドライバタスクとそのタスクに対応したドライバ割り込みハンドラとで
     データのやりとりをするときに使用する。この機能は、セマフォでも代
     用できるので、ドライバによっては使用しない場合もありえる。

  \item メッセージ
     ユーザプロセスと各サーバプロセスとの通信に使用する。
     各サーバプロセスは、システムで決められたメッセージ ID をもつ。そ
     のメッセージ ID を使用してユーザプロセスは、サーバプロセスに対し
     て要求メッセージを送ることができる。
     ユーザプロセスは主にこの IPC 機能を使用するだろう。
\end{enumerate}

  マイクロITRON 3.0 では、この他にも IPC 機能として次の機能を定義して
いる。しかし、本 ITRON では、これ以上の IPC 機能は必要ないと考えサポー
トしていない。各 IPC をサポートしない理由についても付記する。

\begin{description}
  \item[メイルボックス機能]
                        メッセージ機能で代用できるため。また、メイルボ
                        ックス機能では、基本的にアドレス空間を各タスク
                        ごとに共有する必要がある。アドレス空間を基本的
                        に分離している BTRON/386 では、特にユーザプロ
                        セスが使いにくいのではないかと考え、サポートし
                        ないことにした。                        

  \item[ランデブ機能]
                        メッセージ機能で代用できるため削除した。ランデ
                        ブは、ランデブを呼び出したタスクが、呼び出され
                        たタスクからの返事が帰ってくるまで待つことにな
                        っている。しかし、そうするとメッセージを送信し
                        が後に他の処理を行うことができなくなる。
                        BTRON/386 では、サーバが他のサーバを呼び出す場
                        合があり、そうした場合にランデブを使用すると、
                        並列処理ができなるくなるため、効率が悪くなると
                        思われた(処理によってランデブとメッセージを使
                        いわけるというのも考えられるが、そうすると、要
                        求処理が複雑になる)。
\end{description}

  これらの IPC 機能については、ユーザプログラムによっては、必要となる
場合もあるが、そういった場合には、ユーザプログラム自身でこれらの機能を
エミュレートする必要がある。


\subsubsection{セマフォ}

  マイクロ ITRON 3.0 では、セマフォとして計数セマフォをサポートしている。
  本項では、セマフォ機能について説明する。

\paragraph{セマフォ操作のための関数}

  セマフォを操作するための関数の一覧を示す。

  cre\_sem:     セマフォ生成
  del\_sem:     セマフォ削除
  sig\_sem:     セマフォの解放(V 操作)
  wai\_sem:     セマフォの獲得(P 操作)
  preq\_sem:    セマフォの獲得(P 操作); ポーリング機能付き 
  twai\_sem:    セマフォの獲得(P 操作); タイムアウト機能付き
  ref\_sem:     セマフォ状態参照  

  各操作の詳細については、次項で説明する。

\paragraph{セマフォの生成}

  セマフォの生成は、cre\_sem() によって行う。

\paragraph{セマフォの削除}

  セマフォの削除は、del\_sem() によって行う。
  指定した ID をもつセマフォの管理情報をクリアする。

\paragraph{セマフォの解放}

  獲得したセマフォを解放する場合、sig\_sem() を使用する。セマフォの解放
は、セマフォの削除と同一の機能ではない。セマフォの削除の場合、他にセマ
フォの獲得を待っていたタスクは、セマフォを獲得することができず、エラー
が返る。しかし、セマフォを解放した場合には、セマフォの獲得を待っていた
プロセスは、正常にセマフォを獲得することができる。
  この機能は、いわゆるセマフォの V 操作に対応する。

\paragraph{セマフォの獲得}

  セマフォの獲得には、付属の機能を使用するかしないかによって3つの関数
がある。 

\begin{description}
  \item[wai\_sem()]     セマフォを獲得する。すでに他のタスクがセマフォを獲得し
                ていた場合、この関数を実行したタスクはセマフォが解放さ
                れるまで、待ち状態 (TTS\_WAI) に入る。

  \item[preq\_sem()]    Polling 機能付きでセマフォを獲得する。すでに他のタスク
                がセマフォを獲得していた場合、エラー(E\_TMOUT)を返す。
                この関数を実行したタスクは、待ち状態には入らない。

  \item[twai\_sem()]    タイムアウト機能付きでセマフォを獲得する。すでに他のタ
                スクがセマフォを獲得していた場合には、指定したタイムア
                ウト時間だけ待ち、タイムアウト時間が過ぎてもセマフォが
                獲得できなかった場合には、エラー(E\_TMOUT)を返す。
\end{description}

  セマフォの獲得機能は、いわゆるセマフォの P 操作に対応する。

\paragraph{セマフォ状態の参照}

  今、セマフォがどういう状態にあるかは、ref\_sem() によって参照できる。
  ref\_sem() は、セマフォ状態として、次の情報を返す。

        待ちタスクの有無
        セマフォカウント値

\paragraph{ Implementation}

  ITRON で管理するセマフォ管理構造体には、次の情報が含まれている。  

\begin{description}
  \item[ID]             セマフォ ID
  \item[Counter]        現在のセマフォカウント値
  \item[next]           次のセマフォへのポインタ(内部管理情報)。
  \item[before]         前のセマフォへのポインタ(内部管理情報)。
\end{description}

\subsubsection{イベントフラグ}

  イベントフラグとは、タスク間で同期をとるための機構である。
  イベントフラグの待ちを実行すると、イベントフラグが指定した値になるま
で wait 状態になることができる。
  そして、他のタスクが、イベントフラグを指定した値に設定した時に 
wakeup される。

\paragraph{イベントフラグ操作のための関数}

  イベントフラグ操作関数として、以下の関数が使用できる。

\begin{description}
  \item[cre\_flg]{イベントフラグ生成}
  \item[del\_flg]{イベントフラグ削除}
  \item[set\_flg]{イベントフラグのセット}
  \item[clr\_flg]{イベントフラグのクリア}
  \item[wai\_flg]{イベントフラグ待ち}
  \item[pol\_flg]{イベントフラグ待ち(ポーリング機能付き)}
  \item[twai\_flg]{イベントフラグ待ち(タイムアウト機能付き)}
  \item[ref\_flg]{イベントフラグ状態参照}
\end{description}

\paragraph{イベントフラグ生成}

  イベントフラグを使用する場合、まず、cre\_flg によってイベントフラグを
生成しなければならない。
  cre\_flg は引数で指定された ID をもつイベントフラグを新規に生成する。
もし、指定した ID をもつイベントフラグがすでに生成されていたら、エラー
(E\_ID) となる。

\paragraph{イベントフラグ削除}

  使い終ったイベントフラグは、del\_flg によって削除できる。
  もし、指定したイベントフラグを待っているタスクがあった場合にもイベン
トフラグは正常に削除できる。ただしその場合、イベントフラグを待っていた
タスクは、エラー(E\_DLT)となる。

\paragraph{イベントフラグのセット}

  指定した ID をもつイベントフラグをセットする。
  もし、イベントフラグを待っていたタスクがあった場合、そのタスクは 
wakeup される。
  イベントフラグを待つタスクは複数いてもよい。

\paragraph{イベントフラグのクリア}

  指定した ID をもつイベントフラグをクリアする。
  クリアする値は引数で指定できる。

\paragraph{イベントフラグ待ち}

  指定した ID をもつイベントフラグを待つのは、付属した機能によって3つ
の関数にわけることができる。

\begin{description}
  \item[wai\_flg]       一番単純なイベントフラグ待ち関数。
                指定した ID をもつイベントフラグの値が特定のビットパタ
                ーンになるまで、この関数を実行したタスクは、wait 状態
                となる。そして、set\_flg にほってイベントフラグの値が指
                定したビットパターンになると、待ち状態にあったタスクは、
                wakeup する。

  \item[pol\_flg]       イベントフラグの状態を調べ、もしイベントフラグの値が指
                定したビットパターンと合致していれば、正常終了する。ま
                た、ビットフラグの値が指定したビットパターンと一致して
                いない場合にもタスクは待ち状態とならず、呼び出し側に戻
                る。ただし、エラー(E\_TMOUT)を返す。  

  \item[twai\_flg]      wai\_flg にタイムアウト機能を追加したもの。
                イベントフラグの値が指定したビットパターンと一致してい
                なければ、待ち状態となる。そして、指定した時間が過ぎて
                もイベントフラグがセットされなければ、この関数の呼び出
                し側へエラー(E\_TMOUT) 返す。
\end{description}

\paragraph{イベントフラグ状態参照}

  指定したイベントフラグの状態を参照する。
  イベントフラグの状態は、次に示す構造体の形式で返される。

\begin{verbatim}
  typedef struct t\_rflg
  {
    VP          exinf;          /* 拡張情報                             */
    BOOL\_ID    wtsk;           /* 待ちタスクの有無                     */
    UINT        flgptn;         /* イベントフラグのビットパターン       */
  }
\end{verbatim}


\subsubsection{メッセージ}

  メッセージ機能は、BTRON/386 の IPC 機能の中で最も使用されるものであ
る。BTRON としてのシステムコールは、すべてメッセージの送受信としてイン
プメントされており、ファイルを読む動作ひとつとってもメッセージの送受信
によって行われる。その使用頻度からみて、メッセージ機能については、注意
深くインプリメントする必要がある。メッセージによるデータ転送速度が遅い
場合、それはシステムコールの速度低下として現われる。

\paragraph{メッセージ操作のための関数}

  メッセージ操作のための関数の一覧を次に示す。

\begin{description}
  \item[]cre\_mbf:       メッセージバッファを生成する。
  \item[]del\_mbf:       メッセージバッファを削除する。
  \item[]snd\_mbf:       メッセージバッファへ送信する。
  \item[]psnd\_mbf:      メッセージバッファへ送信する(ポーリング機能付き)。
  \item[]tsnd\_mbf:      メッセージバッファへ送信する(タイムアウト機能付き)。
  \item[]rcv\_mbuf:      メッセージバッファから受信する。
  \item[]prcv\_mbf:      メッセージバッファから受信する(ポーリング機能付き)。
  \item[]trcv\_mbf:      メッセージバッファから受信する(タイムアウト機能付き)。
  \item[]ref\_mbf:       メッセージバッファの状態を参照する。
\end{description}

  各操作について、次項以下で説明する。

\paragraph{メッセージバッファの生成}

  メッセージバッファの生成は、cre\_mbf() によって行う。
  メッセージは、その処理のために ITRON 内に一時バッファを必要とする、
cre\_mbf() によって、そのためのバッファを生成する。
  基本的にメッセージバッファのサイズ以上のメッセージを送ることはできな
い。これは、本 ITRON でのメッセージの性質として、1つメッセージを2つ以
上のメッセージとして送ることができなということがあるためである(これを
許可すると、メッセージの切れ目が区別できなくなってしまい、メッセージの
最初がわからなくなる)。

\paragraph{メッセージバッファの削除}

  メッセージバッファの削除によって、指定した ID をもつメッセージの情報
をすべて削除する。
  送信済みのメッセージで、まだ受信していないものについても削除はできる
が、その場合受信待ち状態にあるタスクに対しては、エラー(E\_DLT)が返され
る。

\paragraph{メッセージバッファへの送信}

  指定した ID をもつメッセージバッファへの送信には、オプション機能を使
用するかしないかによって、異なった3つの関数がある。

  snd\_mbf:     メッセージバッファへデータを送信する。
                もし、メッセージバッファに空き領域が存在しない場合には
                、空き領域ができるまで待つ。

  psnd\_mbf:    Polling 機能付きでメッセージバッファへデータを送信する。
                もし、メッセージバッファに空き領域が存在しない場合には
                エラー(E\_TMOUT) を返し即座に呼び出し側に戻る。

  tsnd\_mbf:    タイムアウト機能付きでメッセージバッファへデータを送信
                する。
                もし、メッセージバッファに空き領域が存在しない場合には
                指定した時間だけ待つ。もし、指定した時間が過ぎても空き
                領域ができない場合には、エラー(E\_TMOUT) を返し呼び出し
                側に戻る。

\paragraph{メッセージバッファからの受信}

  指定した ID をもつメッセージバッファへの受信も送信の場合と同じように
オプション機能を使用するかしないかによって、異なった3つの関数がある。

  rcv\_mbf:     メッセージバッファからデータを受信する。
                もし、メッセージバッファにデータがまだ送信されていない
                場合には、タスクは待ち状態となる。

  prcv\_mbf:    Polling 機能付きでメッセージバッファからデータを受信す
                る。 
                もし、メッセージバッファに送信データが存在しない場合に
                はエラー(E\_TMOUT) を返し即座に呼び出し側に戻る。

  trcv\_mbf:    タイムアウト機能付きでメッセージバッファからデータを受
                信する。
                もし、メッセージバッファに送信データが存在しない場合に
                は指定した時間だけ待つ。もし、指定した時間が過ぎてもデ
                ータが送られてこない場合には、エラー(E\_TMOUT) を返し呼
                び出し側に戻る。

\paragraph{メッセージバッファ状態の参照}

  指定したメッセージ ID をもつメッセージバッファが今どういう状態にある
かは、ref\_mbf() によって参照することができる。
  ref\_mbf() は、メッセージバッファ状態として次の情報を返す。

  受信待ちタスクの有無
  送信待ちタスクの有無
  次に受信されるメッセージのサイズ
  空きバッファのサイズ


\subsection{割り込み管理機能}

  割り込み管理機能では、割り込みハンドラの管理(登録/削除/呼び出し)、ソ
フトウェア/ハードウェア割り込みの管理などを行う。

\subsubsection{割り込み管理関数}

  割り込み管理で使用できる関数を以下に示す。

  def\_int      割込みハンドラ定義
  ret\_int      割込みハンドラからの復帰
  ret\_wup      割込みハンドラ復帰とタスク起床(wakeup)
  loc\_cpu      割込みとディスパッチの禁止
  unl\_cpu      割込みとディスパッチの許可
  dis\_int      割込み禁止
  ena\_int      割込み許可
  chg\_iXX      割込みマスク(レベル、優先度)変更
  rel\_iXX      割込みマスク(レベル、優先度)参照


\subsubsection{割込みハンドラ定義}

  ITRON 仕様によると割込みハンドラは、任意に定義することができる。しか
し、ユーザプログラムが任意に割込みハンドラを設定してしまうと、セキュリ
ティの面で問題が発生する可能性もある。
  そのため、この機能はカーネルモードにあるプログラムからしか使用できな
いように制限した。

  割込みハンドラは、def\_int によって定義することができる。

  def\_int は、引数として次の情報をもらう。

\begin{enumerate}
  \item{割込み定義番号}
  \item{割込みハンドラ定義情報}
        \begin{enumerate}
        \item 割込みハンドラ属性 (本 ITRON では使用しない)
        \item 割込みハンドラアドレス
        \end{enumerate}
\end{enumerate}

  割込みハンドラは、タスクからは独立している。そのため、割込みハンドラ
内では自分のタスク情報を参照しようとしてはいけない。


\subsubsection{割込みハンドラからの復帰}

  割込みハンドラからの復帰の機能は、割込みハンドラから使用する。
  割込みハンドラが割込みの延長上での処理を終了すると、この ret\_int を
呼び出す。
  ret\_int は、割込み処理の後始末を行い、割込み前の処理を続行する。

  ref\_int は、具体的に次の処理を行う。

\begin{enumerate}
  \item 使用済みの割込みスタックを削除。
  \item 割込み前の処理に iret 命令で戻る。
\end{enumerate}

  このシステムコールは、呼び出されると呼び出し元には、戻らない。


\subsubsection{割込みハンドラ復帰とタスク起床(wakeup)}

  ret\_wup は、ret\_int (割込みハンドラからの復帰) と、任意のタスク起床
という2つの処理を同時に行う。
  もし、指定したタスクが待ち状態にないときには、wakeup 要求はキューイ
ングされる。


\subsubsection{割込みとディスパッチの禁止}

  外部割込みとディスパッチを禁止する。


\subsubsection{割込みとディスパッチの許可}

  もし、外部割込みとディスパッチを禁止状態にあれば、それを解除する。
  もし、外部割込みとディスパッチを禁止状態になければ何もしない。


\subsubsection{割込み禁止}

  引数で指定した外部割込みを禁止する。
  外部割込みの指定は 80386 の IDT テーブルのインデックスで行う。


\subsubsection{割込み許可}

  dis\_intで指定した外部割込み禁止を解除する。


\subsubsection{割込みマスク(レベル、優先度)変更}

  指定したレベルおよび優先度の割込みのマスクを変更する。
  設定は、chg\_iXX (XX の部分は割込みレベル)で行う。
  割込みマスクを変更すると、マスクされた割込みは禁止(または割込み禁止
を解除)する。


\subsubsection{割込みマスク(レベル、優先度)参照}

  chg\_iXX で設定した割込みのマスク状態を参照する。


\subsection{例外管理機能}

  本 ITRON では、例外管理機能として以下の機能をサポートする。

  システムコールハンドラの設定
  例外発生時の処理

  例外処理ハンドラはタスクごとに指定できる。もし、例外処理をシステムの
デフォルトの処理ですませようとする場合には、ハンドラのアドレスとして 0
(NULL ポインタ)を指定する必要がある(初期値)。

\subsubsection{システムコールハンドラの設定}

  ITRON システムにないシステムコールを設定する機能は、def\_svc が行う。

\subsubsection{例外管理関数}

  例外管理では、次の関数を用意する。

  def\_exc      例外ハンドラの定義
  

\subsection{メモリプール管理機能}

  メモリプール管理機能では、システムのもつ物理メモリの管理を行う。
  ただし、BTRON/386 では、ITRON も含めてすべてのメモリは仮想空間にマッ
ピングしなければ使用できない。そのため、メモリプール管理機能を使って獲
得した物理メモリは、そのままではアクセスできない。
  むしろ、このメモリプール管理機能を使って獲得した物理メモリは、抽象的
なリソースと考えた方がよい。

  マイクロ ITRON 3.0 ではメモリプール管理機能として、固定サイズのメモ
リブロック獲得と可変長サイズのメモリブロック獲得と2つの種類がある。
  本 ITRON では、以下の理由から固定サイズでメモリブロックを獲得する機
能のみサポートすることにした。

\begin{enumerate}
  \item メモリプール管理機能で獲得できるメモリはあくまでも物理メモリであ
     り、仮想メモリ空間にマッピングしなければ役に立たない。
     しかし、仮想空間へのマッピングは、ページサイズでしか行えない
     (80X86の場合 4K バイトサイズ)。ページサイズ以下の単位で物理メモリ
     を獲得できたとしても、仮想メモリにマッピングできないため、結局は
     無駄になってしまう。

  \item ITRON の中でバイト単位のメモリ管理をするのは結構面倒。
     むしろ、細かいメモリ管理はITRONよりも上のレベルで行った方がよい。
\end{enumerate}

  なお、ITRON では、固定長メモリブロックの場合でも取得するメモリブロッ
クのサイズはメモリプール生成時に指定できる(たとえば、10 バイト単位のメ
モリブロックを管理するメモリプールなど)。しかし、上の理由でページサイ
ズ以外の大きさのブロックを管理することは意味がないため、指定するメモリ
ブロックの大きさは 4K バイト固定とした。


\subsection{時間管理機能}



\subsection{システム管理機能}

  システム管理機能では、ITRON 環境の設定を行う。

  

\subsection{仮想メモリ管理機能}

  仮想メモリ管理機能については、システム依存による部分が大きいこともあ
り、マイクロ ITRON 3.0 では、内容を定義していない。
  そのため、仮想メモリ管理機能についてはインプリメント依存のシステムコ
ールとして最初に v のついた名前として定義する\footnote{
  これらの関数を決めるにあたっては、「ＩＴＲＯＮ入門」でのITRON/MMUに
  関する記述を参考にしました。}

  仮想メモリの設定は、タスク毎に行う。また、タスク生成時には、親のタス
クの仮想メモリの設定をそのまま引き継ぐ。そのため、タスク生成直後には、
同じ物理メモリを使うタスクが2つできることになる(UNIXのようなメモリ管理
と違い、タスク生成時に新たに物理メモリを用意するようなことはしない)。
そのため、BTRON サーバが、BTRON プロセスを生成するときに、ユーザ空間を
パージし、新しく仮想空間を作成、指定されたプログラムをロードする。


\subsubsection{仮想メモリ管理機能関連のシステムコール}

  仮想メモリ管理機能でサポートするシステムコールの一覧を示す。

  vcre\_spc:    仮想空間を1つ作成する。
  vdel\_spc:    仮想空間を1つ削除する。
  vcre\_map:    論理ページを物理ページに割り付ける。
  vdel\_map:    論理ページと物理ページの割り付けを削除する。
  vsha\_map:    論理空間の共有割り付けを行う。
  vget\_dat:    指定した論理空間からデータを読み出す。
  vput\_dat:    指定した論理空間にデータを書き込む。
  vget\_atr:    仮想メモリの属性を取得する。
  vset\_atr:    仮想メモリの属性を設定する。
  vset\_vmh:    ページフォールト時のハンドラを定義する。

  各システムコールの詳細について、次項以下で説明する。

\paragraph{仮想メモリエントリの作成}

\paragraph{仮想メモリエントリの削除}

\paragraph{仮想メモリの属性を取得する}

\paragraph{仮想メモリの属性を設定する}

\paragraph{ページフォルト時のハンドラを定義する}


\subsubsection{仮想メモリ管理のインプリメンテーション}

  BTRON/386 での、仮想メモリのメモリマップを示す。

\begin{verbatim}
  0x00000000    : ユーザモード領域
        .
        .
        .
  0x7FFFFFFF
  0x80000000    : 
        .
        .
        .
  0x800FFFFF
  0x80010000    : ITRON カーネル
        .
        .
        .
  0x801FFFFF
\end{verbatim}
  

%
%
%
\section{BTRON サーバ}


%
%
%
\section{マネージャ}

\subsection{マネージャとは何か}
\subsection{ウィンドウマネージャ}
\subsection{パーツマネージャ}
\subsection{パネルマネージャ}
\subsection{メニューマネージャ}
\subsection{データマネージャ}
\subsection{トレイマネージャ}
\subsection{フォントマネージャ}
\subsection{文字入力マネージャ}
\subsection{仮身/実身マネージャ}

%
%
%
\section{ライブラリ}

BTRON/386 ではアプリケーションを開発するためにライブラリが
ある。

システムにはじめからついているライブラリ(以後「標準ライブラリ」と
呼ぶ)としては、次の種類がある(Table: \ref{tab:standard-library})。

\begin{table}[h]
\begin{center}
        \caption{標準ライブラリ}
        \label{tab:standard-library}
        \begin{tabular}{l | l}                                     \hline
        ライブラリ名    &       内容                            \\ \hline
        libsyscall.a    &       システムコールなど              \\ \hline
        libhigh.a       &       高機能ライブラリ                \\ \hline
        libposix.a      &       POSIX エミュレーション用ライブラリ \\ \hline
        \end{tabular}
\end{center}
\end{table}


\subsection{ライブラリ}
\subsection{API}
\subsection{その他 \ldots POSIX ライブラリ}

%
%
%
\section{アプリケーション}
\subsection{システムアプリケーション}
\subsection{ファインダー}
\subsection{基本文章エディタ}
\subsection{基本図形エディタ}

% Local Variables:
% mode: japanese-LaTeX
% TeX-master: "btron386"
% end:
