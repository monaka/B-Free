doc/note/architecture.txt	-*- text -*-
$Revision: 1.1 $


[B-Free Memo 1]






		   B-Free 基本アーキテクチャ定義
		   --------------------------------


		 B-Free Architecture Specification





		     +--------------------------+
		     | F i r s t      D r a f t |
		     +--------------------------+



	*Abstruct*

	本ドキュメントは、B-Free の基本構成および各構成要素について、
	概略を記述している。詳細な仕様については他のドキュメントを参照
	のこと。 


注意
====

  このドキュメントでの ITRON に関係する記述は、μITRON3.0標準ハンドブ
ックの内容を前提に書かれています。
  ITRON 自体の仕様については、μITRON3.0標準ハンドブックを参考にしてく
ださい。

用語の定義
==========

  本ドキュメントおよび B-Free OS で使用する用語について以下のように定
  義する。

1 タスクとプロセス

  本 B-Free OS ではタスクとプロセスとを区別している。
  タスクというのは、ITRON レベルで管理するときに使用する。タスクには、
CPU 資源およびメモリ資源情報が含まれており、ファイル管理情報などは含ま
れていない。ユーザプログラムレベルでは通常タスクという単位では意識しな
い。
  プロセスは、B-Free OS のプログラムの実行がされている状態のときを表す
言葉である。プロセスには、タスクとしての情報の他に B-Free OS のプログ
ラムの実行時に必要な情報も含む(ファイル管理情報など)。
  BTRON サーバが管理するプロセスとしての意味を強調したい場合には、特に
BTRON プロセスという言葉を使う場合もある。


2 ITRON

  本ドキュメントで扱う ITRON は、「マイクロ ITRON 3.0 ハンドブック」に
記述された仕様を基にしている。
  ITRON (Industorial TRON) は、元々組み込みコンピュータ用としてその仕
様が決められている。しかし、本 B-Free OS の OS のコア部分として ITRON 
を採用する場合には、必要がない部分や足りない機能があるのは確かである。
そこで、ITRON 仕様については、必要ない部分については仕様を省略し、あく
までも B-Free OS のコア部分として必要なものだけを選択することにした。
  また、マイクロ ITRON 3.0 の仕様には MMU の使用についてはインプリメン
ト依存として規定されていないため、その使用方法については B-Free OS と
して独自に仕様を決めた。


3 BTRON

  本 B-Free OS では、BTRON の仕様として「BTRON 1 プログラミング標準ハン
ドブック」および「BTRON1 仕様ソフトウェア仕様 Ver.1.20.00.00」を参考に
している(ただし、アーキテクチャについては独自の構成をとっている)。


4 例外と割込み

  B-Free OS (とITRON) では例外と割込みを明確に区別している。
  例外 (Exception) は、外部からの割込み以外のソフトウェア割込みまたは
CPU が発生する例外を意味する。
  割込み (Interrupt) は、外部からの割込みを意味する。内部的な割込みは
例外として別に扱われる。

アーキテクチャ階層
==================

  B-Free OS は、いくつかの階層に分かれている。以下に各階層について簡単
な説明を示す。

(0) ハードウェア
    B-Free OS では、ハードウェアとしてインテル 80386 プロセッサを積ん
    だパーソナルコンピュータを対象にしている。インテル以外のプロセッサ
    を使用しているパーソナルコンピュータに B-Free OS が動作するかは、
    それら(80386 以外のプロセッサを積んだマシン)をもっている人の努力に
    よる。

(1) ITRON (本当のカーネル)
    ITRON層は、カーネルモードで動作し、B-Free OS の一番基本的な層とし
    て上位層を管理する。

(2) 周辺核 (BTRON サーバタスク)
    周辺核は、BTRON としての機能を提供する。BTRON 機能としては、ファイ
    ル管理機能/プロセス管理機能などが含まれる。BTRONサーバは、ITRONの
    タスクとして インプリメントする。  

(3) デバイスドライバタスク (群)
    ITRON タスクとしてインプリメントする。

(4) マネージャ (群)
    BTRON プロセスとしてインプリメントする。

(5) ユーザプログラム


  この階層構造をみて分かるように、B-Free OS は、マイクロカーネル「風」
のアーキテクチャを採用している。


ITRON
=====

    マイクロ ITRON3.0 基本仕様(一部拡張仕様も含む)準拠のカーネル。

    次の機能をもつ。

    タスク管理
    同期・通信機能(IPC)
    割り込み管理機能
    例外管理機能
    メモリプール管理機能
    時間管理機能
    システム管理機能
    仮想メモリ管理機能
    
  この層は、基本的な OS の機能を上位層に与える。
  なお、上位層はこの ITRON に対してシステムコールを発行することによっ
て、ITRONの機能を使用する。しかし、ITRON より上位の層は、すべて(デバイ
スドライバも含めて)メッセージの送受信により要求を受けとるようになって
いる。トラップを介して呼び出されるというのは ITRON だけである。
  アプリケーションが、BTRON の機能を使用する場合、次のような順序で処理
する。

  1) ITRON に対してシステムコールを発行して、BTRON システムコール管理
     タスクへメッセージを送る。
  2) BTRON システムコール管理タスクは、送られてきたメッセージを受けと
     り、メッセージに書かれた要求を処理する。
  3) BTRON システムコール管理タスクは、システムコールを処理すると、結
     果をメッセージの形にして ITRON を介してアプリケーションへ送る。
  4) アプリケーションは、メッセージを受けとる。
     (システムコールの終了)

  結局、ITRON は、メッセージの仲介をするというのが一番重要な機能になる
と思われる。
  なお、ITRON を呼び出すというのは、通常ライブラリだけであり、アプリケ
ーション ITRON を意識する必要はない。ファイルの読み書きなどの処理は、
ファイル管理タスクが、メッセージを受けとることによって処理する。
  また、本 ITRON では、マイクロITRON 3.0 で新たに拡張された接続機能に
ついては、サポートしない。異なったホスト間での通信機能については、
ITRON レベルよりも更に上層の機能でサポートする。


1. タスク管理

1.1  ITRON のタスク管理の設計目標

   1) できる限りコンテクストスイッチを速くする。
   2) タスク管理ブロック (TCB) の大きさを小さくする。

  ITRON のタスク管理では、コンテキストを構造体の形では、管理しない。そ
の代りにタスク切り替え時にスタック上にコンテキストを収めるようにする。
  つまり、次に切り換えられるタスクのスタックの一番上にそのタスクのコン
テキストがのっかっていなければならない。


1.2 タスク管理情報

  タスクを管理する情報としては次のものがある。

  1) タスク ID
  2) タスク属性
  3) タスク状態
  4) タスク待ち要因
  5) タスク優先度
  6) 仮想メモリ管理テーブル
  7) カーネルスタック
  8) IPC (Inter process communication) 用の情報
  9) 例外処理ハンドラテーブル

  * ITRON レベルでは、ファイルシステムについての情報は意識していない。
    ファイルシステムについての情報については、BTRON レベル(BTRON サー
    バ)で管理する。

1.2.1 タスク ID

  タスク ID は、各タスクを識別するための情報である。そのため、タスク 
  ID は、各タスクごとにユニークな番号が割り当てられる。
  本 ITRON では、タスク情報の配列のインデックスが割りあてられる。
  タスク ID は 1 以上の数が割りあてられる。また、タスク ID 0 は、自分
  自身のタスクを表わす。
	

1.2.2 タスク属性

  タスク属性は、タスクを記述する言語が何であるかを示す情報である。
  この情報は ITRON 規約によって決められているものだが、本 ITRON では、
  アセンブラと高級言語で記述されたことの区別はつけないため、常に高級言
  語で記述した場合の値(TA_HLNG)が入る。

1.2.3 タスク状態

  現在のタスクの状態を示す。
  タスクの状態は、次に示す値のどれかになっている(マクロ名を示す。括弧
  内は、実際の値)。

  TTS_NON(0x00000000):	未生成状態。
  TTS_RUN(0x00000001):	走行状態。この値を示すタスクは、常にシステム内
			で1つだけである。
  TTS_RDY(0x00000002):	走行可能状態。
  TTS_WAI(0x00000004):	待ち状態。自分でイベントを待つことを指定した場
			合にこの値をもつ。
  TTS_SUS(0x00000008):	強制待ち状態。他のタスクから強制的に待ち状態に
			された場合、この値をもつ。
  TTS_WAS(0x00000010):	タスクが待ち状態に入っている場合に、他のタスク
			から強制的に待ち状態に、この値をもつ。
  TTS_DMT(0x00000020):	休止状態。タスクが生成されてはいるがまだ起動さ
			れていない場合にこの値をもつ。この状態のときに
			は、タスクは自分の資源をなにも消費していない。

1.2.4 タスク待ち要因

  TTS_WAI,TTS_SUS,TTS_WASのいずれかの状態のときに、何の要因で待ち状態
  に入っているのかを示す値である。

  待ちとして以下の状態を定義している:

	タイマ待ち	(セマフォ、イベントフラ、メッセージの待ちと組
			み合わせて使う)
	セマフォ待ち
	イベントフラグ待ち
	メッセージ待ち

  セマフォ/イベントフラグ/メッセージは、タイマ待ちと組み合わせることが
できる。
  逆にタイマ待ちを除いては、セマフォ/イベントフラグ/メッセージの待ち状
態は重なることがない(例えばイベントフラグとセマフォとを同時に待つこと
はない)。


1.2.5 タスク優先度

  タスク優先度は、タスクを実行する場合にどのタスクを先に実行するかを示
  す値である。もし、同じ優先度のタスクがあった場合、その優先度のタスク
  リストの先頭にあるタスクが先に実行される。タスクリストについては、タ
  スクの構造を参照のこと。

1.2.6 仮想メモリ管理テーブル

  タスクごとに必要とする仮想メモリのマッピング情報。
  カーネルモードでは、すべて同じマッピングだが、ユーザモード(アプリケ
ーションプログラム)の領域は、マッピング情報がタスクごとに異なっている。
  仮想メモリ管理テーブルの詳細については、仮想メモリ機能の項目を参照の
  こと。

1.2.7 カーネルスタック

  タスクごとにもつスタック領域。
  この大きさはタスクの生成時に指定される。本来の ITRON 規約ではバイト
  単位でサイズを指定するが、本 ITRON では、ページサイズに切り上げられ
  る。これは、スタック領域をオーバーフローしたことを関知するために、ス
  タック領域の前後のページを未マップ状態にするためである。スタック領域
  をはずれてアクセスした場合にどのような処理をするかは、例外処理ハンド
  ラとして各タスクごとに指定することができる。

1.2.8 IPC (Inter process communication) 用の情報

  本 ITRON では、タスク間通信として次の機能をサポートしている。

  1) セマフォ
  2) メッセージ
  3) イベントフラグ

  通信機能に必要な情報は、タスク情報として各タスクに付随している。

1.2.9 例外処理ハンドラテーブル

  例外が発生した場合に実行されるハンドラへのアドレスを収めるテーブル。
  例外には、次の種類がある。

  1) メモリフォールト
  2) トラップ (システムコール)
  3) 浮動小数点例外

  もし、例外発生時にタスク独自の処理をする必要がなければ、システムで決
  められた処理を行う。その場合、ハンドラアドレスとしてアドレス 0 (NULL
  ポインタ)をセットしておくこと。
  例外処理の詳細については、例外処理機能の項目を参照のこと。


1.3 タスク切り替えの処理

  1) まず前提として、各タスクは独自のスタックをもっている。
     これは、関数呼び出し時などに使われるのはもちろんだが、タスク切り
     替え時には、タスクの情報(コンテキスト)を保存する場所としても使わ
     れる。

  2) タスク切り替えを行う関数
     タスク切り替えは、switch_task() という関数が行う。
     switch_task() は、次の呼び出し形式をもつ:

     switch_task(taskid)
     taskid:	次に切り替えるタスクのID。これは、タスク配列のインデッ
		クスとなっている。


2. 同期・通信機構(IPC)

2.1 本 ITRON でサポートしている同期・通信機能

  本来の ITRON 規約では、セマフォ、イベントフラグ、メイルボックス、メ
ッセージバッファ、ランデブなどが使用できる。しかし、これらの機能をすべ
てをサポートすることは、B-Free OS を動かすためだけには必要ないと思われ
るので、本 ITRON では、セマフォ、イベントフラグ、メッセージしかサポー
トしていない。
  各 IPC 機能は、次の用途を目的としてサポートした。

  1) セマフォ
     タスク間の同期をとる。タスク間で共有している情報をアクセスすると
     きなどに使用する。

  2) イベントフラグ
     タスク間で待ち状態を指定するときなどに使用する。
     ドライバタスクとそのタスクに対応したドライバ割り込みハンドラとで
     データのやりとりをするときに使用する。この機能は、セマフォでも代
     用できるので、ドライバによっては使用しない場合もありえる。

  3) メッセージ
     ユーザプロセスと各サーバプロセスとの通信に使用する。
     各サーバプロセスは、システムで決められたメッセージ ID をもつ。そ
     のメッセージ ID を使用してユーザプロセスは、サーバプロセスに対し
     て要求メッセージを送ることができる。
     ユーザプロセスは主にこの IPC 機能を使用するだろう。

  マイクロITRON 3.0 では、この他にも IPC 機能として次の機能を定義して
いる。しかし、本 ITRON では、これ以上の IPC 機能は必要ないと考えサポー
トしていない。各 IPC をサポートしない理由についても付記する。

  メイルボックス機能：	メッセージ機能で代用できるため。また、メイルボ
			ックス機能では、基本的にアドレス空間を各タスク
			ごとに共有する必要がある。アドレス空間を基本的
			に分離している B-Free OS では、特にユーザプロ
			セスが使いにくいのではないかと考え、サポートし
			ないことにした。			

  ランデブ機能：	メッセージ機能で代用できるため削除した。ランデ
			ブは、ランデブを呼び出したタスクが、呼び出され
			たタスクからの返事が帰ってくるまで待つことにな
			っている。しかし、そうするとメッセージを送信し
			が後に他の処理を行うことができなくなる。
			B-Free OS では、サーバが他のサーバを呼び出す場
			合があり、そうした場合にランデブを使用すると、
			並列処理ができなるくなるため、効率が悪くなると
			思われた(処理によってランデブとメッセージを使
			いわけるというのも考えられるが、そうすると、要
			求処理が複雑になる)。

  これらの IPC 機能については、ユーザプログラムによっては、必要となる
場合もあるが、そういった場合には、ユーザプログラム自身でこれらの機能を
エミュレートする必要がある。


2.1 セマフォ

  マイクロ ITRON 3.0 では、セマフォとして計数セマフォをサポートしている。
  本項では、セマフォ機能について説明する。

2.1.1 セマフォ操作のための関数

  セマフォを操作するための関数の一覧を示す。

  cre_sem:	セマフォ生成
  del_sem:	セマフォ削除
  sig_sem:	セマフォの解放(V 操作)
  wai_sem:	セマフォの獲得(P 操作)
  preq_sem:	セマフォの獲得(P 操作); ポーリング機能付き 
  twai_sem:	セマフォの獲得(P 操作); タイムアウト機能付き
  ref_sem:	セマフォ状態参照  

  各操作の詳細については、次項で説明する。

2.1.2 セマフォの生成

  セマフォの生成は、cre_sem() によって行う。

2.1.3 セマフォの削除

  セマフォの削除は、del_sem() によって行う。
  指定した ID をもつセマフォの管理情報をクリアする。

2.1.4 セマフォの解放

  獲得したセマフォを解放する場合、sig_sem() を使用する。セマフォの解放
は、セマフォの削除と同一の機能ではない。セマフォの削除の場合、他にセマ
フォの獲得を待っていたタスクは、セマフォを獲得することができず、エラー
が返る。しかし、セマフォを解放した場合には、セマフォの獲得を待っていた
プロセスは、正常にセマフォを獲得することができる。
  この機能は、いわゆるセマフォの V 操作に対応する。

2.1.4 セマフォの獲得

  セマフォの獲得には、付属の機能を使用するかしないかによって3つの関数
がある。 

  wai_sem():	セマフォを獲得する。すでに他のタスクがセマフォを獲得し
		ていた場合、この関数を実行したタスクはセマフォが解放さ
		れるまで、待ち状態 (TTS_WAI) に入る。

  preq_sem():	Polling 機能付きでセマフォを獲得する。すでに他のタスク
		がセマフォを獲得していた場合、エラー(E_TMOUT)を返す。
		この関数を実行したタスクは、待ち状態には入らない。

  twai_sem():	タイムアウト機能付きでセマフォを獲得する。すでに他のタ
		スクがセマフォを獲得していた場合には、指定したタイムア
		ウト時間だけ待ち、タイムアウト時間が過ぎてもセマフォが
		獲得できなかった場合には、エラー(E_TMOUT)を返す。

  セマフォの獲得機能は、いわゆるセマフォの P 操作に対応する。

2.1.5 セマフォ状態の参照

  今、セマフォがどういう状態にあるかは、ref_sem() によって参照できる。
  ref_sem() は、セマフォ状態として、次の情報を返す。

	待ちタスクの有無
	セマフォカウント値

2.1.5  Implementation

  ITRON で管理するセマフォ管理構造体には、次の情報が含まれている。  

  ID:		セマフォ ID
  Counter:	現在のセマフォカウント値
  next:		次のセマフォへのポインタ(内部管理情報)。
  before:	前のセマフォへのポインタ(内部管理情報)。


2.2 イベントフラグ

  イベントフラグとは、タスク間で同期をとるための機構である。
  イベントフラグの待ちを実行すると、イベントフラグが指定した値になるま
で wait 状態になることができる。
  そして、他のタスクが、イベントフラグを指定した値に設定した時に 
wakeup される。

2.2.1 イベントフラグ操作のための関数

  イベントフラグ操作関数として、以下の関数が使用できる。

  cre_flg	イベントフラグ生成
  del_flg	イベントフラグ削除
  set_flg	イベントフラグのセット
  clr_flg	イベントフラグのクリア
  wai_flg	イベントフラグ待ち
  pol_flg	イベントフラグ待ち(ポーリング機能付き)
  twai_flg	イベントフラグ待ち(タイムアウト機能付き)
  ref_flg	イベントフラグ状態参照

2.2.2 イベントフラグ生成

  イベントフラグを使用する場合、まず、cre_flg によってイベントフラグを
生成しなければならない。
  cre_flg は引数で指定された ID をもつイベントフラグを新規に生成する。
もし、指定した ID をもつイベントフラグがすでに生成されていたら、エラー
(E_ID) となる。

2.2.3 イベントフラグ削除

  使い終ったイベントフラグは、del_flg によって削除できる。
  もし、指定したイベントフラグを待っているタスクがあった場合にもイベン
トフラグは正常に削除できる。ただしその場合、イベントフラグを待っていた
タスクは、エラー(E_DLT)となる。

2.2.4 イベントフラグのセット

  指定した ID をもつイベントフラグをセットする。
  もし、イベントフラグを待っていたタスクがあった場合、そのタスクは 
wakeup される。
  イベントフラグを待つタスクは複数いてもよい。

2.2.5 イベントフラグのクリア

  指定した ID をもつイベントフラグをクリアする。
  クリアする値は引数で指定できる。

2.2.6 イベントフラグ待ち

  指定した ID をもつイベントフラグを待つのは、付属した機能によって3つ
の関数にわけることができる。

  wai_flg	一番単純なイベントフラグ待ち関数。
		指定した ID をもつイベントフラグの値が特定のビットパタ
		ーンになるまで、この関数を実行したタスクは、wait 状態
		となる。そして、set_flg にほってイベントフラグの値が指
		定したビットパターンになると、待ち状態にあったタスクは、
		wakeup する。

  pol_flg	イベントフラグの状態を調べ、もしイベントフラグの値が指
		定したビットパターンと合致していれば、正常終了する。ま
		た、ビットフラグの値が指定したビットパターンと一致して
		いない場合にもタスクは待ち状態とならず、呼び出し側に戻
		る。ただし、エラー(E_TMOUT)を返す。  

  twai_flg	wai_flg にタイムアウト機能を追加したもの。
		イベントフラグの値が指定したビットパターンと一致してい
		なければ、待ち状態となる。そして、指定した時間が過ぎて
		もイベントフラグがセットされなければ、この関数の呼び出
		し側へエラー(E_TMOUT) 返す。

2.2.9 イベントフラグ状態参照

  指定したイベントフラグの状態を参照する。
  イベントフラグの状態は、次に示す構造体の形式で返される。

  typedef struct t_rflg
  {
    VP		exinf;		/* 拡張情報				*/
    BOOL_ID	wtsk;		/* 待ちタスクの有無			*/
    UINT	flgptn;		/* イベントフラグのビットパターン	*/
  }


2.3 メッセージ

  メッセージ機能は、B-Free OS の IPC 機能の中で最も使用されるものであ
る。BTRON としてのシステムコールは、すべてメッセージの送受信としてイン
プメントされており、ファイルを読む動作ひとつとってもメッセージの送受信
によって行われる。その使用頻度からみて、メッセージ機能については、注意
深くインプリメントする必要がある。メッセージによるデータ転送速度が遅い
場合、それはシステムコールの速度低下として現われる。

2.3.1 メッセージ操作のための関数

  メッセージ操作のための関数の一覧を次に示す。

  cre_mbf:	メッセージバッファを生成する。
  del_mbf:	メッセージバッファを削除する。
  snd_mbf:	メッセージバッファへ送信する。
  psnd_mbf:	メッセージバッファへ送信する(ポーリング機能付き)。
  tsnd_mbf:	メッセージバッファへ送信する(タイムアウト機能付き)。
  rcv_mbuf:	メッセージバッファから受信する。
  prcv_mbf:	メッセージバッファから受信する(ポーリング機能付き)。
  trcv_mbf:	メッセージバッファから受信する(タイムアウト機能付き)。
  ref_mbf:	メッセージバッファの状態を参照する。

  各操作について、次項以下で説明する。

2.3.2 メッセージバッファの生成

  メッセージバッファの生成は、cre_mbf() によって行う。
  メッセージは、その処理のために ITRON 内に一時バッファを必要とする、
cre_mbf() によって、そのためのバッファを生成する。
  基本的にメッセージバッファのサイズ以上のメッセージを送ることはできな
い。これは、本 ITRON でのメッセージの性質として、1つメッセージを2つ以
上のメッセージとして送ることができなということがあるためである(これを
許可すると、メッセージの切れ目が区別できなくなってしまい、メッセージの
最初がわからなくなる)。

2.3.3 メッセージバッファの削除

  メッセージバッファの削除によって、指定した ID をもつメッセージの情報
をすべて削除する。
  送信済みのメッセージで、まだ受信していないものについても削除はできる
が、その場合受信待ち状態にあるタスクに対しては、エラー(E_DLT)が返され
る。

2.3.4 メッセージバッファへの送信

  指定した ID をもつメッセージバッファへの送信には、オプション機能を使
用するかしないかによって、異なった3つの関数がある。

  snd_mbf:	メッセージバッファへデータを送信する。
		もし、メッセージバッファに空き領域が存在しない場合には
		、空き領域ができるまで待つ。

  psnd_mbf:	Polling 機能付きでメッセージバッファへデータを送信する。
		もし、メッセージバッファに空き領域が存在しない場合には
		エラー(E_TMOUT) を返し即座に呼び出し側に戻る。

  tsnd_mbf:	タイムアウト機能付きでメッセージバッファへデータを送信
		する。
		もし、メッセージバッファに空き領域が存在しない場合には
		指定した時間だけ待つ。もし、指定した時間が過ぎても空き
		領域ができない場合には、エラー(E_TMOUT) を返し呼び出し
		側に戻る。

2.3.5 メッセージバッファからの受信

  指定した ID をもつメッセージバッファへの受信も送信の場合と同じように
オプション機能を使用するかしないかによって、異なった3つの関数がある。

  rcv_mbf:	メッセージバッファからデータを受信する。
		もし、メッセージバッファにデータがまだ送信されていない
		場合には、タスクは待ち状態となる。

  prcv_mbf:	Polling 機能付きでメッセージバッファからデータを受信す
		る。 
		もし、メッセージバッファに送信データが存在しない場合に
		はエラー(E_TMOUT) を返し即座に呼び出し側に戻る。

  trcv_mbf:	タイムアウト機能付きでメッセージバッファからデータを受
		信する。
		もし、メッセージバッファに送信データが存在しない場合に
		は指定した時間だけ待つ。もし、指定した時間が過ぎてもデ
		ータが送られてこない場合には、エラー(E_TMOUT) を返し呼
		び出し側に戻る。

2.3.6 メッセージバッファ状態の参照

  指定したメッセージ ID をもつメッセージバッファが今どういう状態にある
かは、ref_mbf() によって参照することができる。
  ref_mbf() は、メッセージバッファ状態として次の情報を返す。

  受信待ちタスクの有無
  送信待ちタスクの有無
  次に受信されるメッセージのサイズ
  空きバッファのサイズ


3. 割り込み管理機能

  割り込み管理機能では、割り込みハンドラの管理(登録/削除/呼び出し)、ソ
フトウェア/ハードウェア割り込みの管理などを行う。

3.1 割り込み管理関数

  割り込み管理で使用できる関数を以下に示す。

  def_int	割込みハンドラ定義
  ret_int	割込みハンドラからの復帰
  ret_wup	割込みハンドラ復帰とタスク起床(wakeup)
  loc_cpu	割込みとディスパッチの禁止
  unl_cpu	割込みとディスパッチの許可
  dis_int	割込み禁止
  ena_int	割込み許可
  chg_iXX	割込みマスク(レベル、優先度)変更
  rel_iXX	割込みマスク(レベル、優先度)参照


3.2 割込みハンドラ定義

  ITRON 仕様によると割込みハンドラは、任意に定義することができる。しか
し、ユーザプログラムが任意に割込みハンドラを設定してしまうと、セキュリ
ティの面で問題が発生する可能性もある。
  そのため、この機能はカーネルモードにあるプログラムからしか使用できな
いように制限した。

  割込みハンドラは、def_int によって定義することができる。

  def_int は、引数として次の情報をもらう。

  1) 割込み定義番号
  2) 割込みハンドラ定義情報
     (1) 割込みハンドラ属性 (本 ITRON では使用しない)
     (2) 割込みハンドラアドレス

  割込みハンドラは、タスクからは独立している。そのため、割込みハンドラ
内では自分のタスク情報を参照しようとしてはいけない。


3.3 割込みハンドラからの復帰

  割込みハンドラからの復帰の機能は、割込みハンドラから使用する。
  割込みハンドラが割込みの延長上での処理を終了すると、この ret_int を
呼び出す。
  ret_int は、割込み処理の後始末を行い、割込み前の処理を続行する。

  ref_int は、具体的に次の処理を行う。

  1) 使用済みの割込みスタックを削除。
  2) 割込み前の処理に iret 命令で戻る。

  このシステムコールは、呼び出されると呼び出し元には、戻らない。


3.4 割込みハンドラ復帰とタスク起床(wakeup)

  ret_wup は、ret_int (割込みハンドラからの復帰) と、任意のタスク起床
という2つの処理を同時に行う。
  もし、指定したタスクが待ち状態にないときには、wakeup 要求はキューイ
ングされる。


3.5 割込みとディスパッチの禁止

  外部割込みとディスパッチを禁止する。


3.6 割込みとディスパッチの許可

  もし、外部割込みとディスパッチを禁止状態にあれば、それを解除する。
  もし、外部割込みとディスパッチを禁止状態になければ何もしない。


3.7 割込み禁止

  引数で指定した外部割込みを禁止する。
  外部割込みの指定は 80386 の IDT テーブルのインデックスで行う。


3.8 割込み許可

  dis_intで指定した外部割込み禁止を解除する。


3.9 割込みマスク(レベル、優先度)変更

  指定したレベルおよび優先度の割込みのマスクを変更する。
  設定は、chg_iXX (XX の部分は割込みレベル)で行う。
  割込みマスクを変更すると、マスクされた割込みは禁止(または割込み禁止
を解除)する。


3.10 割込みマスク(レベル、優先度)参照

  chg_iXX で設定した割込みのマスク状態を参照する。


4. 例外管理機能

  本 ITRON では、例外管理機能として以下の機能をサポートする。

  システムコールハンドラの設定
  例外発生時の処理

  例外処理ハンドラはタスクごとに指定できる。もし、例外処理をシステムの
デフォルトの処理ですませようとする場合には、ハンドラのアドレスとして 0
(NULL ポインタ)を指定する必要がある(初期値)。

4.1 システムコールハンドラの設定

  ITRON システムにないシステムコールを設定する機能は、def_svc が行う。

4.2 例外管理関数

  例外管理では、次の関数を用意する。

  def_exc	例外ハンドラの定義
  

5. メモリプール管理機能

  メモリプール管理機能では、システムのもつ物理メモリの管理を行う。
  ただし、B-Free OS では、ITRON も含めてすべてのメモリは仮想空間にマッ
ピングしなければ使用できない。そのため、メモリプール管理機能を使って獲
得した物理メモリは、そのままではアクセスできない。
  むしろ、このメモリプール管理機能を使って獲得した物理メモリは、抽象的
なリソースと考えた方がよい。

  マイクロ ITRON 3.0 ではメモリプール管理機能として、固定サイズのメモ
リブロック獲得と可変長サイズのメモリブロック獲得と2つの種類がある。
  本 ITRON では、可変長サイズでメモリブロックを獲得する機能のみサポー
トすることにした。
  ただし、ITRON 内部ではメモリ管理として以下のようにいくつかのレベルを
もつ。

  1) 最下位レベル (ページ単位のメモリ管理)
  2) ITRON 内部で使用するメモリ管理 (バイト単位のメモリ管理)
  3) ITRON システムコールレベルのメモリ管理


5.1 最下位レベルのメモリ管理

  最下位レベルのメモリ管理では、ページ単位のメモリアロケートを行う。

  init_memory	--- メモリ管理部の初期化
  palloc	--- 指定したページ数だけメモリをアロケートする
  pfree		--- 指定したページ数だけメモリをフリーする


5.2 ITRON 内部で使用するメモリ管理

  ITRON 内部では、ページ単位のメモリ管理の他にバイト単位でもメモリ管理
を行う。

  init_malloc	--- ページ単位のメモリアロケート部の初期化
  kalloc	--- 指定したバイト数分だけメモリをアロケート
  kfree		--- kalloc で確保したメモリをフリーする


5.3 ITRON システムコールレベルのメモリ管理

  ITRON システムコールとして次のものを提供する。

  cre_mpl		メモリプールの生成
  del_mpl		可変長メモリプールの削除
  get_blk		可変長メモリブロック獲得
  pget_blk		可変長メモリブロック獲得(ポーリング)
  tget_blk		可変長メモリブロック獲得(タイムアウト有)
  rel_blk		可変長メモリブロック返却
  ref_mpl		可変長メモリプール状態参照


6. 時間管理機能

  時間管理機能では、システムクロックの管理やタスクの周期的実行などの時
間に関係した管理を行う。


7. システム管理機能

  システム管理機能では、ITRON 環境の設定を行う。
  また、中心核のバージョン番号も管理する。
  

8. 仮想メモリ管理機能

  仮想メモリ管理機能については、システム依存による部分が大きいこともあ
り、マイクロ ITRON 3.0 では、内容を定義していない。
  そのため、仮想メモリ管理機能についてはインプリメント依存のシステムコ
ールとして最初に v のついた名前として定義する。

  仮想メモリの設定は、タスク毎に行う。また、タスク生成時には、親のタス
クの仮想メモリの設定をそのまま引き継ぐ。そのため、タスク生成直後には、
同じ物理メモリを使うタスクが2つできることになる(UNIXのようなメモリ管理
と違い、タスク生成時に新たに物理メモリを用意するようなことはしない)。
そのため、BTRON サーバが、BTRON プロセスを生成するときに、ユーザ空間を
パージし、新しく仮想空間を作成、指定されたプログラムをロードする。


8.1 仮想メモリ管理機能関連のシステムコール

  仮想メモリ管理機能でサポートするシステムコールの一覧を示す。

  vcre_vme:	create virtual memory entry.
  vdel_vme:	delete virtual memory entry.
  vget_atr:	仮想メモリの属性を取得する。
  vset_atr:	仮想メモリの属性を設定する。
  vset_vmh:	ページフォールト時のハンドラを定義する。


8.2 仮想メモリマップ

  B-Free OS での、仮想メモリのメモリマップを示す。

  0x00000000	: ユーザモード領域
	.
	.
	.
  0x7FFFFFFF
  0x80000000	: 
	.
	.
	.
  0x800FFFFF
  0x80010000	: ITRON カーネル
	.
	.
	.
  0x801FFFFF
  


周辺核
======

  BTRON 関係のシステムコールを処理する。
  周辺核はいくつかの ITRON タスクによって構成する実は、BTRON システム
コールは、メッセージの形でこのプロセスに送られるようになっている。メッ
セージの形にするのは、ライブラリで行うので、アプリケーション本体は、本
当のシステムコールなのかは区別する必要はない。

  これらのタスクは、ユーザタスクごとに BTRON のシステムコールの処理に
必要な情報を管理している(ファイルのオープンテーブルなど)。
  仮想メモリを管理機能では、各タスクごとに仮想メモリのテーブルをもち、
ページングをする時には、そのテーブルを引いて、ディスクのどこに物理メモ
リのデータをおさめたらよいかを決める。
  よりハードウェアに近い仮想メモリの管理は、ITRONが行う。

  * 周辺核「タスク」は、自分自身のファイル管理などは行わないためタスク
    としている(プロセスではない)。

デバイスドライバタスク (群)
===========================

  いわゆるデバイスドライバ。
  B-Free OS では、デバイスドライバをタスクとしてインプリメントすること
にした。このようなインプリメントでは、タスクではないドライバなどに比較
して、以下の利点および欠点がある。

  利点
  	タスクとして動作するため自分だけの情報を保持することができる。
	また、処理の流れとして 要求取得 -> 要求の処理 -> 結果返答 とい
	うサイクルを繰りかえせばいいため、見とおしがよい。
	タスクとしてデバイスドライバがない場合、要求の保持のために要求
	待ち行列を別に作る必要がある場合がある。	

  欠点
  	タスクとして管理するためのデータが必要となる。

  デバイスドライバは、最初の実行時にデバイスドライバ管理テーブルに登録
しなければならない。


1 デバイスドライバの構造

  基本的にデバイスドライバは、次のような処理の流れをもつ。

device_driver ()
{
  <デバイスドライバの登録>
  <デバイスドライバ自身の初期化>

  while (1)	/* 無限ループ */
    {
      処理要求メッセージ受信
      要求の処理
      返答メッセージ送信
    }
}

  要求の処理を行う時点では、別のタスクを生成してそのタスクに処理をまか
せ、元のデバイスドライバタスクは、次のメッセージを受けとってもよい。


2 メッセージの形式

  デバイスドライバへ送られるメッセージの形式は、デバイスドライバメッセ
ージとして決められている。


2.1 メッセージの種類

  デバイスドライバメッセージの種類を以下に示す。

  デバイス初期化要求
  デバイスのオープン要求
  デバイスのクローズ要求
  データ読み出し
  データ書き込み
  デバイス状態の取り出し
  論理デバイス名取り出し
  割り込みメッセージ(デバイスドライバの割り込み処理から発行)

  このうち、割り込みメッセージ以外はすべてユーザプログラム(あるいはサ
ーバ群)が発行する。


2.2 デバイス初期化要求

  デバイスを初期化する。


  送信メッセージ形式：

  メッセージ識別番号		4バイト(0x00000001 固定値)
  返信メッセージバッファ ID	4バイト


  返信メッセージ形式:

  メッセージ識別番号		4バイト(0x00000001 固定値)
  送信時のメッセージバッファ ID	4バイト
  返却値			2バイト


2.3 デバイスのオープン要求

  デバイスをオープンする。オープンした場合、オープン要求を送ったタスク
がデバイスをクローズするまでそのデバイスがオープンできなくなる(ロック
されるか)どうかは、各デバイスの処理に依存する。

  送信メッセージ形式：

  メッセージ識別番号		4バイト(0x00000002 固定値)
  返信メッセージバッファ ID	4バイト
  オープンモード		4バイト


  返信メッセージ形式:

  メッセージ識別番号		4バイト(0x00000002 固定値)
  送信時のメッセージバッファ ID	4バイト
  返却値			2バイト


2.4 デバイスのクローズ要求

  送信メッセージ形式：

  メッセージ識別番号		4バイト(0x00000003 固定値)
  返信メッセージバッファ ID	4バイト
  オープンモード		4バイト


  返信メッセージ形式:

  メッセージ識別番号		4バイト(0x00000003 固定値)
  送信時のメッセージバッファ ID	4バイト
  返却値			2バイト


2.5 データ読み込み

  デバイスからデータを読み込む。
  読み込んだデータは、送信メッセージのエントリ データバッファのアドレ
スへと書き込まれる。デバイスドライバは、カーネルモ-ドで動作し、ユーザ
プログラムのアドレス空間へは自由にアクセスできる。そのため、データバッ
ファは、特に共有メモリ空間を指定する必要はない。

  送信メッセージ形式：

  メッセージ識別番号		4バイト(0x00000004 固定値)
  返信メッセージバッファ ID	4バイト
  読み込み開始オフセット	4バイト
  読み込みサイズ		4バイト
  自分のタスク ID		2バイト
  データバッファのアドレス	4バイト

  返信メッセージ形式:

  メッセージ識別番号		4バイト(0x00000004 固定値)
  送信時のメッセージバッファ ID	4バイト
  返却値			2バイト
  読み込んだデータのサイズ	4バイト


2.6 データ書き込み

  デバイスからデータを読み込む。
  書き込むデータは、送信メッセージのエントリ データバッファのアドレス
から読み込まれる。デバイスドライバは、カーネルモ-ドで動作し、ユーザプ
ログラムのアドレス空間へは自由にアクセスできる。そのため、データバッフ
ァは、特に共有メモリ空間を指定する必要はない。

  送信メッセージ形式：

  メッセージ識別番号		4バイト(0x00000005 固定値)
  返信メッセージバッファ ID	4バイト
  書き込み開始オフセット	4バイト
  書き込みサイズ		4バイト
  自分のタスク ID		2バイト
  データバッファのアドレス	4バイト

  返信メッセージ形式:

  メッセージ識別番号		4バイト(0x00000005 固定値)
  送信時のメッセージバッファ ID	4バイト
  返却値			2バイト
  書き込んだデータのサイズ	4バイト


2.7 デバイス状態の取り出し

  送信メッセージ形式：

  メッセージ識別番号		4バイト(0x00000006 固定値)
  返信メッセージバッファ ID	4バイト
  オープンモード		4バイト


  返信メッセージ形式:

  メッセージ識別番号		4バイト(0x00000006 固定値)
  送信時のメッセージバッファ ID	4バイト
  返却値			2バイト
  デバイス状態			16 バイト

  デバイス状態は以下に示す構造体である。

  typedef DEV_STATE
  {
    UW	attr;		デバイス属性
    UW	mode;		現在のアクセスモード
    W	blksz;		物理ブロックサイズ
    W	wprt;		0:書込み許可、1:書込み禁止
  }


2.8 論理デバイス名取り出し

  送信メッセージ形式：

  メッセージ識別番号		4バイト(0x00000007 固定値)
  返信メッセージバッファ ID	4バイト


  返信メッセージ形式:

  メッセージ識別番号		4バイト(0x00000007 固定値)
  送信時のメッセージバッファ ID	4バイト
  返却値			2バイト
  デバイス名			16バイト


2.9 割り込みメッセージ

  このメッセージは、デバイスドライバの割り込み処理部分(タスク独立部)か
ら送信され、ユーザプログラムからは送信されない。
  ユーザプログラムから本メッセージを送信した場合、エラーとなる。

  送信メッセージ形式：

  メッセージ識別番号		4バイト(0x00000008 固定値)
  返信メッセージバッファ ID	4バイト
  割り込み ID			2バイト

  < 本メッセージについての返答形式はない >


  

マネージャ
==========

  B-Free OS では次のマネージャをサポートする。

   ディスプレイマネージャ
   ウィンドウマネージャ
   メニューマネージャ
   パーツマネージャ
   パネルマネージャ
   トレーマネージャ
   データマネージャ
   フォントマネージャ
   テキスト入力プリミティブマネージャ
   実身/仮身マネージャ
   印刷マネージャ
   スプールマネージャ
   [ネットワークマネージャ]

  これらのマネージャのうちネットワークマネージャについては現状ではサポ
ーしない。ネットワーク機能については、後で検討することにする。

  BTRON1 仕様では、マネージャへの要求はトラップを使用したシステムコー
ルとして定義している。しかし、B-Free OSでは、マネージャへの要求はメッ
セージを介して行うこととした。


1. ディスプレイマネージャ

  ディスプレイマネージャは、ディスプレイへの表示管理やプリミティブ画像
の表示などを行う。
  ディスプレイマネージャへの要求はメッセージ ID 00000002 によって行う。


2. ウィンドウマネージャ

  ウィンドウマネージャは、ウィンドウの描画/表示やウィンドウ情報の管理
などを行う。


3. メニューマネージャ

  メニューマネージャは、アプリケーションが表示するメニューについて管理
する。


4. パーツマネージャ

  パーツマネージャは、ウィンドウ内に表示するパーツについて表示およびイ
ベント管理を行う。


5. パネルマネージャ

  パネルは、アプリケーションがユーザからのレスポンスが必要な場合に表示
するウィンドウである。
  パネルマネージャでは、アプリケーションがパネル機能を簡単に使用できる
ように、パネル管理機能を提供する。


6. トレーマネージャ

  アプリケーション間でデータのやりとりを行うための方法としてトレーを使
用することができる。
  トレーマネージャでは、システムにあるトレー情報の管理を行う。
  (B-Free OS では、ユーザに対してトレーの内容を表示/操作する機能も提供
する。ただしこれは、トレーマネージャではなく、専用のアプリケーションが
行う)


7. データマネージャ

  データを管理する。  


8. フォントマネージャ

  フォント情報の管理を行う。


9. テキスト入力プリミティブマネージャ

  テキスト入力プリミティブマネージャは、キーボードから入力イベントを受
け取り、必要に応じてかな漢字変換を行う機能をユーザプロセスに提供する。
  B-Free OS では、かな漢字変換サーバとして Canna を使用する。


10. 実身/仮身マネージャ

  実身/仮身情報について、アプリケーションが扱いやすいような機能を提供
する。


11. 印刷マネージャ

  プリンタの種類によらず、アプリケーションから統一的な印刷方法を提供す
る。


12. スプールマネージャ

  プリントアウトする場合に、印刷要求をスプーリングする。



ユーザプログラム
================

  ユーザプログラムは、次の2つ種類がある。

	o 32ビットモードユーザプログラム
	o 16ビットモードユーザプログラム(80286 mode)

  16ビットモードは、1B/Note に代表される PMC の一連の BTRON パソコンで
動いているプログラム(アプリケーション)を動かすために存在する。


1. 32ビットモードユーザプログラム

  32 ビットモードユーザプログラムは、GCC (GNU CC) の実行形式としてコン
パイルしたものを前提にしている。

  そのため、実行プログラムのヘッダ部分は GNU CC の a.out の形式と同一
のものとなっている。BTRON1 の仕様とは異なっているので注意すること。


2. 16ビットモードユーザプログラム(80286 mode)

  16 ビットモードユーザプログラム(80286 mode) は、BTRON/1 で作成された
アプリケーションについて互換性を保つために設定された。
  ただし、最初のバージョンではサポートしない。


$Log: architecture.txt,v $
Revision 1.1  2011/12/27 17:13:36  liu1
Initial Version.

Revision 1.3  1994-08-20 15:07:58  night
ファイルの文字コードを EUC に変更。

